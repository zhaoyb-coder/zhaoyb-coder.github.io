(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{364:function(t,a,r){"use strict";r.r(a);var e=r(7),s=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"thread"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#thread"}},[t._v("#")]),t._v(" Thread")]),t._v(" "),a("h2",{attrs:{id:"thread-生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#thread-生命周期"}},[t._v("#")]),t._v(" Thread 生命周期")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://s2.loli.net/2022/07/25/qavOoJjibIWUKRy.png",alt:"image-20220725185145548"}})]),t._v(" "),a("h3",{attrs:{id:"_1、新建状态-new"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、新建状态-new"}},[t._v("#")]),t._v(" 1、"),a("strong",[t._v("新建状态")]),t._v("（New）")]),t._v(" "),a("blockquote",[a("p",[t._v("当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();")])]),t._v(" "),a("h3",{attrs:{id:"_2、就绪状态-runnable"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、就绪状态-runnable"}},[t._v("#")]),t._v(" 2、"),a("strong",[t._v("就绪状态")]),t._v("（Runnable）")]),t._v(" "),a("blockquote",[a("p",[t._v("当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；")])]),t._v(" "),a("h3",{attrs:{id:"_3、运行状态-running"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、运行状态-running"}},[t._v("#")]),t._v(" 3、"),a("strong",[t._v("运行状态")]),t._v("（Running）")]),t._v(" "),a("blockquote",[a("p",[t._v("当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就   绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；")])]),t._v(" "),a("h3",{attrs:{id:"_4、阻塞状态-blocked"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、阻塞状态-blocked"}},[t._v("#")]),t._v(" 4、"),a("strong",[t._v("阻塞状态")]),t._v("（Blocked）")]),t._v(" "),a("blockquote",[a("p",[t._v("处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：")]),t._v(" "),a("ul",[a("li",[t._v("等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；")]),t._v(" "),a("li",[t._v("同步阻塞 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；")]),t._v(" "),a("li",[t._v("其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。")])])]),t._v(" "),a("h3",{attrs:{id:"_5、死亡状态-dead"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5、死亡状态-dead"}},[t._v("#")]),t._v(" 5、"),a("strong",[t._v("死亡状态")]),t._v("（Dead）")]),t._v(" "),a("blockquote",[a("p",[t._v("线程执行完了或者因异常退出了run()方法，该线程结束生命周期。")])])])}),[],!1,null,null,null);a.default=s.exports}}]);