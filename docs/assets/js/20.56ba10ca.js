(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{497:function(t,o,e){"use strict";e.r(o);var a=e(30),r=Object(a.a)({},(function(){var t=this,o=t.$createElement,e=t._self._c||o;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"linux-事件处理模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#linux-事件处理模式"}},[t._v("#")]),t._v(" Linux-事件处理模式")]),t._v(" "),e("h2",{attrs:{id:"_1、reactor模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、reactor模式"}},[t._v("#")]),t._v(" 1、Reactor模式")]),t._v(" "),e("blockquote",[e("p",[t._v("同步I/O模型通常用于实现Reactor模式")])]),t._v(" "),e("p",[t._v("Reactor模式要求主线程（I/O处理单元）只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元），除此之外主线程不做任何其它实质性的工作（读写数据、接受新连接、以及处理客户端请求均在工作线程中完成）")]),t._v(" "),e("hr"),t._v(" "),e("p",[e("strong",[t._v("使用epoll_wait实现Reactor模式：")])]),t._v(" "),e("p",[t._v("1、主线程往epoll内核事件表中注册socket的读就绪事件")]),t._v(" "),e("p",[t._v("2、主线程调用epoll_wait等待socket上有数据可读")]),t._v(" "),e("p",[t._v("3、当socket上有数据可读时，epoll_wait通知主线程。主线程将socket可读事件放入请求队列")]),t._v(" "),e("p",[t._v("4、睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户端请求，然后往epoll内核事件表中注册该socket上的写就绪事件")]),t._v(" "),e("p",[t._v("5、主线程调用epoll_wait等待socket可写")]),t._v(" "),e("p",[t._v("6、当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列")]),t._v(" "),e("p",[t._v("7、睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户端请求的结果")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/image-20240305160720106.png",alt:"image-20240305160720106"}})]),t._v(" "),e("h2",{attrs:{id:"_2、proactor模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、proactor模式"}},[t._v("#")]),t._v(" 2、Proactor模式")]),t._v(" "),e("blockquote",[e("p",[t._v("异步I/O模型则用于实现Proactor模式")])]),t._v(" "),e("p",[t._v("Proactor模式把所有I/O操作都交给主线程和内核去处理，工作线程仅仅负责业务逻辑")]),t._v(" "),e("hr"),t._v(" "),e("p",[e("strong",[t._v("使用aio_read/aio_write实现Proactor模式:")])]),t._v(" "),e("p",[t._v("1、主线程调用aio_read向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序。")]),t._v(" "),e("p",[t._v("2、主线程继续处理其它逻辑")]),t._v(" "),e("p",[t._v("3、当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，用来通知应用程序数据已经可用")]),t._v(" "),e("p",[t._v("4、应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求，工作线程处理完客户请求之后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序")]),t._v(" "),e("p",[t._v("5、主线程继续处理其它逻辑")]),t._v(" "),e("p",[t._v("6、当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕")]),t._v(" "),e("p",[t._v("7、应用程序预选定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/image-20240305160818356.png",alt:"image-20240305160818356"}})])])}),[],!1,null,null,null);o.default=r.exports}}]);