(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{499:function(t,e,r){"use strict";r.r(e);var a=r(30),o=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"linux-i-o模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#linux-i-o模型"}},[t._v("#")]),t._v(" Linux-I/O模型")]),t._v(" "),r("h2",{attrs:{id:"_1、阻塞i-o"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1、阻塞i-o"}},[t._v("#")]),t._v(" 1、阻塞I/O")]),t._v(" "),r("blockquote",[r("p",[t._v("阻塞的文件描述符称之为阻塞I/O")])]),t._v(" "),r("p",[t._v("对于阻塞IO的系统调用可能因为无法立即完成而被操作系统挂起，直到等待的事件发生为止")]),t._v(" "),r("p",[t._v("比如客户端通过connect向服务器发起连接时，connect首先发送同步报文给服务器，然后等待服务器的返回确认报文段，如果服务器没有立即返回报文段，则connect调用将会被挂起，直到客户端收到确认报文段并唤醒connect调用")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/image-20240305160216703.png",alt:"image-20240305160216703"}})]),t._v(" "),r("p",[r("img",{attrs:{src:"https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/image-20240305160253699.png",alt:"image-20240305160253699"}})]),t._v(" "),r("h2",{attrs:{id:"_2、非阻塞i-o"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2、非阻塞i-o"}},[t._v("#")]),t._v(" 2、非阻塞I/O")]),t._v(" "),r("blockquote",[r("p",[t._v("非阻塞的文件描述符称之为非阻塞I/O")])]),t._v(" "),r("p",[t._v("对于非阻塞IO的调用总是立即返回，而不管事件是否发生。")]),t._v(" "),r("p",[t._v("如果事件没有发生，就返回-1（和出错的情况一样），这时必须根据errno来区分这两种情况。")]),t._v(" "),r("p",[t._v("对于accept、send、recv来说，事件未发生时errno通常被设置为EAGAIN（再来一次）或者EWOULDBLOCK（期望阻塞）；对于connect来说，errno被设置为EINPROGRESS（处理中）")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/image-20240305160323549.png",alt:"image-20240305160323549"}})]),t._v(" "),r("p",[r("strong",[t._v("只有在事件已经发生时操作非阻塞I/O才能提高程序的效率，所以非阻塞I/O通常和其它I/O通知机制一起使用（比如I/O复用和SIGIO信号）")])]),t._v(" "),r("p",[r("img",{attrs:{src:"https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/image-20240305160410111.png",alt:"image-20240305160410111"}})]),t._v(" "),r("hr"),t._v(" "),r("p",[r("strong",[t._v("总结：")])]),t._v(" "),r("p",[t._v("同步I/O模型要求用户代码自行执行I/O操作（将数据从内核缓冲区读入用户缓冲区 或者 将数据从用户缓冲区写入内核缓冲区）")]),t._v(" "),r("p",[t._v("异步I/O模型则由内核来执行I/O操作（数据从内核缓冲区到用户缓冲区之间的移动是内核在“后台”完成的）")]),t._v(" "),r("p",[t._v("同步I/O向应用程序通知的是I/O就绪事件")]),t._v(" "),r("p",[t._v("异步I/O向应用程序通知的是I/O完成事件")])])}),[],!1,null,null,null);e.default=o.exports}}]);