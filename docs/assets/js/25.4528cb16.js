(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{503:function(a,t,_){"use strict";_.r(t);var v=_(30),e=Object(v.a)({},(function(){var a=this,t=a.$createElement,_=a._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h1",{attrs:{id:"jmm-java内存模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jmm-java内存模型"}},[a._v("#")]),a._v(" JMM（Java内存模型）")]),a._v(" "),_("h2",{attrs:{id:"_1、前言"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、前言"}},[a._v("#")]),a._v(" 1、前言")]),a._v(" "),_("p",[a._v("对于现在处理器而言，不可能只靠CPU进行所有的任务计算处理，必须要依靠存储设置进行数据存储，那么CPU和I/O之间的效率差距就变成了一个无法跨越的话题。")]),a._v(" "),_("p",[a._v("为了解决差距过大的问题，就在CPU和存储设置之间加入了多层的读写速度尽可能和CPU一致的高速缓存(Cache),将运算需要的数据先读取到缓存中，然后CPU进行运算，运算结束后，再从缓存同步到内存之中除了告诉缓存之外，处理器还可以对输入代码进行"),_("code",[a._v("乱序执行（Out-Of-Order Execution）")]),a._v("优化，能保证结果相同，但是过程有差异。")]),a._v(" "),_("p",[a._v("但是引入了缓存，就要考虑新的问题，"),_("code",[a._v("缓存一致性")]),a._v("问题，在多路处理器中，每一个处理器都有自己的高速缓存，而所有处理器都共享一个主内存，这整体构成了一个"),_("code",[a._v("共享内存多核系统")]),a._v("。为了解决缓存一致性问题，不同的物理机器都有自己的协议或者内存模型来进行规范。Java虚拟机也有自己的内存模型JMM（Java Memory Model）")]),a._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/image-20231229143024651.png",alt:"image-20231229143024651"}})]),a._v(" "),_("h2",{attrs:{id:"_2、概述"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、概述"}},[a._v("#")]),a._v(" 2、概述")]),a._v(" "),_("h3",{attrs:{id:"_2-1、内存规范"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1、内存规范"}},[a._v("#")]),a._v(" 2.1、内存规范")]),a._v(" "),_("p",[a._v("1、所有变量都存储在主内存中")]),a._v(" "),_("p",[a._v("2、每个线程都有自己的工作内存，线程的工作内存保存了该线程使用变量的主内存副本，线程对变量的所有操作（读写）都必须在工作内存中进行，而不能直接读取主内存的数据")]),a._v(" "),_("p",[a._v("3、不同的线程无法访问对方工作内存中的变量，各线程中的变量传递都必须通过主内存来完成")]),a._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/image-20231229143733343.png",alt:"image-20231229143733343"}})]),a._v(" "),_("h3",{attrs:{id:"_2-2、内存间交互操作"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2、内存间交互操作"}},[a._v("#")]),a._v(" 2.2、内存间交互操作")]),a._v(" "),_("p",[a._v("一个变量如何从主内存拷贝到工作内存，再从工作内存同步到主内存，JMM定义了以下8种操作。")]),a._v(" "),_("ul",[_("li",[a._v("lock（锁定）：作用于主内存的变量，它把变量标识为一条线程独占的状态")]),a._v(" "),_("li",[a._v("unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其它线程锁定")]),a._v(" "),_("li",[a._v("read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到工作内存中，以便随后的load动作使用")]),a._v(" "),_("li",[a._v("load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放到工作内存的变量副本中")]),a._v(" "),_("li",[a._v("use（使用）：作用于工作内存的变量，它把一个从执行引擎接收的值赋值给工作内存的变量，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作")]),a._v(" "),_("li",[a._v("assign（赋值）：")])])])}),[],!1,null,null,null);t.default=e.exports}}]);