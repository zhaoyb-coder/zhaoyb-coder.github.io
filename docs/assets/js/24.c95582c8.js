(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{503:function(a,t,_){"use strict";_.r(t);var v=_(30),s=Object(v.a)({},(function(){var a=this,t=a.$createElement,_=a._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h1",{attrs:{id:"jvm概述"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm概述"}},[a._v("#")]),a._v(" JVM概述")]),a._v(" "),_("h3",{attrs:{id:"_1、jvm运行时区"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、jvm运行时区"}},[a._v("#")]),a._v(" 1、JVM运行时区")]),a._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/image-20231225135517480.png",alt:"image-20231225135517480"}})]),a._v(" "),_("h4",{attrs:{id:"_1-1、程序计数器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1、程序计数器"}},[a._v("#")]),a._v(" 1.1、程序计数器")]),a._v(" "),_("p",[a._v("程序计数器就是当前线程执行的行数指示器")]),a._v(" "),_("h4",{attrs:{id:"_1-2、虚拟机栈-本地方法栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2、虚拟机栈-本地方法栈"}},[a._v("#")]),a._v(" 1.2、虚拟机栈/本地方法栈")]),a._v(" "),_("p",[a._v("Hot-Spot 虚拟机把虚拟机栈和本地方法栈合二为一，内部主要存储局部变量表、操作数栈、动态连接、方法出口等信息")]),a._v(" "),_("p",[a._v("每一个方法从调用到执行完毕的过程，就是一个栈帧在虚拟机栈中从入栈到出栈的过程")]),a._v(" "),_("h4",{attrs:{id:"_1-4、堆"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-4、堆"}},[a._v("#")]),a._v(" 1.4、堆")]),a._v(" "),_("h4",{attrs:{id:"_1-5、方法区"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-5、方法区"}},[a._v("#")]),a._v(" 1.5、方法区")]),a._v(" "),_("p",[a._v("存储的是被虚拟机加载的类型信息、常量、静态变量、即时编译后代码缓存等数据")]),a._v(" "),_("h4",{attrs:{id:"_1-6、直接内存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-6、直接内存"}},[a._v("#")]),a._v(" 1.6、直接内存")]),a._v(" "),_("p",[a._v("直接内存代表着不是JVM内存的一部分，属于操作系统内存，但是也可以被JVM使用，比如引入NIO之后可以使用Native函数库直接分配堆外内存，然后存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样的场景可以提交效率，避免在Java堆和Native堆进行来回复制数据。")]),a._v(" "),_("p",[a._v("直接内存的大小可以根据-XX：MaxDirectMemorySize来设置，如果不进行设置，则大小与堆的最大值-Xmx一致。")]),a._v(" "),_("h3",{attrs:{id:"_2、java对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、java对象"}},[a._v("#")]),a._v(" 2、Java对象")]),a._v(" "),_("p",[a._v("对象实例是否全部分配到堆上？")]),a._v(" "),_("p",[a._v("不是的，随着Java的发展，逃逸分析越来越精确，比如标量替换、栈上分配等优化手段，一些Java实例也可以直接在虚拟机栈中进行分配，这些实例随着栈帧的出栈而销毁，不需要GC的处理。")]),a._v(" "),_("h4",{attrs:{id:"_2-1、如何分配对象内存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1、如何分配对象内存"}},[a._v("#")]),a._v(" 2.1、如何分配对象内存")]),a._v(" "),_("ul",[_("li",[_("strong",[a._v("指针碰撞")]),a._v("\n如果堆中的内存是完全规整的，所有未被使用的内存都被放在一起，那么分配一个对象内存只需要把指针向空闲的内存方向移动一定的距离就可以了。")]),a._v(" "),_("li",[_("strong",[a._v("空闲列表")]),a._v("\n如果堆中的内存并不规整，已使用内存和空闲内存交叉在一起，那么JVM需要维护一个空闲内存的列表，在分配内存的时候从列表中取出足够大的空间划分为实例对象。")])]),a._v(" "),_("p",[a._v("具体使用哪种方式进行内存分配，需要根据内存是否规整来决定；内存是否规整，取决于JVM使用哪种垃圾收集器；当使用的是Serial、ParNew等带有压缩整理的收集器时，系统采用的是指针碰撞来分配内存；当使用CMS来当做垃圾收集器时，理论上只能使用空闲列表来分配内存")]),a._v(" "),_("p",[a._v("除了划分可用内存之外，还有一个需要考虑的问题，就是并发问题。如果对A分配内存的时候，这块内存同时被B使用了，这种问题有两种解决方案：")]),a._v(" "),_("p",[a._v("一种是进行同步处理，虚拟机使用CAS的失败重试进行内存分配，来保证更新内存的原子性")]),a._v(" "),_("p",[a._v("一种是每个线程在JVM堆中预先分配一小块内存（"),_("strong",[a._v("本地线程分配缓冲区Thread Local Allocation Buffer TLAB")]),a._v("），线程先在TLAB中分配内存，如果内存分配完了，后续在需要进行同步分配；")]),a._v(" "),_("p",[a._v("虚拟机是否使用TLAB，使用参数控制 -XX: +/-UseTLAB")]),a._v(" "),_("h4",{attrs:{id:"_2-2、对象的组成"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2、对象的组成"}},[a._v("#")]),a._v(" 2.2、对象的组成")]),a._v(" "),_("p",[a._v("对象在堆内的存储布局分为三个部分："),_("strong",[a._v("对象头(Header)、实例数据(Instance)和对齐填充(Padding)")])]),a._v(" "),_("h5",{attrs:{id:"_2-3-1、对象头"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-1、对象头"}},[a._v("#")]),a._v(" 2.3.1、对象头")]),a._v(" "),_("p",[a._v("对象头分为两类信息")]),a._v(" "),_("p",[a._v("1、存储对象自身的运行时数据 （Mark Word）")]),a._v(" "),_("ul",[_("li",[a._v("哈希码(HashCode)")]),a._v(" "),_("li",[a._v("GC分代年龄")]),a._v(" "),_("li",[a._v("锁状态标志")]),a._v(" "),_("li",[a._v("线程持有的锁")]),a._v(" "),_("li",[a._v("偏向线程ID")]),a._v(" "),_("li",[a._v("偏向时间戳")]),a._v(" "),_("li",[a._v("等")])]),a._v(" "),_("p",[a._v("2、类型指针")]),a._v(" "),_("p",[a._v("JVM通过这个指针来确定该对象是哪一个类的实例")]),a._v(" "),_("p",[a._v("此外，如果对象是一个数组，那么对象头还必须要存储数组长度。")]),a._v(" "),_("h5",{attrs:{id:"_2-3-2、对齐填充"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-2、对齐填充"}},[a._v("#")]),a._v(" 2.3.2、对齐填充")]),a._v(" "),_("p",[a._v("并不是必须的，仅仅是占位符的作用。因为HotSpot 虚拟机要求对象的起始地址必须是8字节的整数倍，也就是对象的大小必须是8字节的整数倍。对象头已经被精心设计为了8字节的整数倍（1或者2），以为如果实例对象的大小不满足8字节的整数倍，那么缺少的部分将由对齐填充来补全")]),a._v(" "),_("h4",{attrs:{id:"_2-3、对象的访问"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-3、对象的访问"}},[a._v("#")]),a._v(" 2.3、对象的访问")]),a._v(" "),_("p",[a._v("Java程序使用对象的方式是在栈上的reference数据来操作对堆中的具体对象。如何定位到堆中的实例化对象，一般有两种方法作为实现：句柄和指针 （HotSpot主要使用指针）")]),a._v(" "),_("p",[a._v("1、如果使用句柄的话，在java堆中需要单独划分一块内存作为句柄池，reference中存储的对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息；")]),a._v(" "),_("p",[_("code",[a._v("使用句柄的好处就是reference中存储的是稳定的句柄地址，在对象移动时（GC移动对象）改变的只是句柄中的实例数据指针，而reference本身不需要更改")])]),a._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/image-20231225153029023.png",alt:"image-20231225153029023"}})]),a._v(" "),_("p",[a._v("2、使用指针直接访问对象，reference存储的直接就是对象地址")]),a._v(" "),_("p",[_("code",[a._v("使用指针的好处就是能直接访问对象，少了一次中间的开销")])]),a._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/image-20231225153400409.png",alt:"image-20231225153400409"}})]),a._v(" "),_("h3",{attrs:{id:"_3、垃圾收集"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3、垃圾收集"}},[a._v("#")]),a._v(" 3、垃圾收集")]),a._v(" "),_("blockquote",[_("p",[a._v("Java 与 C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想 进去，墙里面的人却想出来")])]),a._v(" "),_("h4",{attrs:{id:"_3-1、如何找到垃圾"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-1、如何找到垃圾"}},[a._v("#")]),a._v(" 3.1、如何找到垃圾")]),a._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/image-20231226142132502.png",alt:"image-20231226142132502"}})]),a._v(" "),_("p",[a._v("哪些对象是GC Roots对象：")]),a._v(" "),_("ul",[_("li",[a._v("在虚拟机栈（栈帧中的局部变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等")]),a._v(" "),_("li",[a._v("在方法区中 类静态属性引用的对象，譬如Java类的引用类型静态变量")]),a._v(" "),_("li",[a._v("在方法区中常量引用的对象，譬如字符串常量池中的引用")]),a._v(" "),_("li",[a._v("在本地方法栈中引用的对象（Native方法）")]),a._v(" "),_("li",[a._v("Java虚拟机内部的引用，如基本数据类型对应的Class对象、异常对象、类加载器等")]),a._v(" "),_("li",[a._v("所有被同步锁（synchronized）持有的对象")])]),a._v(" "),_("h4",{attrs:{id:"_3-2、垃圾收集算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2、垃圾收集算法"}},[a._v("#")]),a._v(" 3.2、垃圾收集算法")]),a._v(" "),_("h5",{attrs:{id:"_3-2-1、记忆集-remembered-set"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-1、记忆集-remembered-set"}},[a._v("#")]),a._v(" 3.2.1、记忆集（Remembered Set）")]),a._v(" "),_("p",[a._v("为什么会存在记忆集，为了解决什么问题？")]),a._v(" "),_("p",[a._v("由于大部分的垃圾收集算法都是分代收集，把整个堆划分为了年轻代和老年代，而年轻代和老年代有着各自的垃圾收集器，在进行垃圾收集的过程中，可能存在着"),_("code",[a._v("跨代引用")]),a._v("的问题，这个问题会导致在收集年轻代的时候，为了避免跨代引用，同时需要进行扫描整个老年代，防止老年代中有对象在引用年轻代的某些对象，这种扫描代价比较大。")]),a._v(" "),_("p",[_("code",[a._v("记忆集")]),a._v("就是为了解决跨代引用问题，记忆集存储在新生代，里面的数据结构把整个老年代划分为若干区域，并标识出哪一块存在跨代引用，在发生年轻代GC的时候，只需要把存在跨代引用的哪一块内存中的对象加入GCRoots进行扫描，从而避免了对于老年代的全量扫描")]),a._v(" "),_("h6",{attrs:{id:"_3-2-1-1、卡表-card-table"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-1-1、卡表-card-table"}},[a._v("#")]),a._v(" 3.2.1.1、卡表（Card Table）")]),a._v(" "),_("p",[a._v("记忆集是一个抽象的概念，描述应该记录什么样的数据，而卡表就是具体的实现。类似于Map和HashMap之间的关系")]),a._v(" "),_("p",[a._v("卡表的实现简单到可以只是一个字节数组，HotSpot 默认的卡表标记逻辑如下：")]),a._v(" "),_("div",{staticClass:"language-java line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[a._v("CARD_TABLE "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),a._v(" address "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">>")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("9")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[a._v("1")]),_("br")])]),_("p",[a._v("字节数组CARD_TABLE的每一个元素，都对应着其标识的内存区域中的一小块内存("),_("code",[a._v("卡页 Card Page")]),a._v("）。")]),a._v(" "),_("p",[a._v("HotSpot 中使用的卡页是2的9次幂，即512字节，也就是把卡表标识的内存区域分成了512字节的一个个卡页。")]),a._v(" "),_("p",[a._v("一个卡页内包含多个对象，只要有一个对象存在跨代引用，就把这整个卡页标识为1，也就是卡页变脏(Dirty)，当发生GC时，很轻松就可以获取到脏页中的对象放入GCRoots中。")]),a._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/image-20231227154056965.png",alt:"image-20231227154056965"}})]),a._v(" "),_("h6",{attrs:{id:"_3-2-1-2、写屏障"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-1-2、写屏障"}},[a._v("#")]),a._v(" 3.2.1.2、写屏障")]),a._v(" "),_("p",[a._v("现在还有一个问题，就是如何触发卡页变脏？")]),a._v(" "),_("p",[a._v("时间点是明确的，就是发生跨代引用时，需要把对应的卡表变脏，也就是在对象引用字段赋值的那一刻进行变脏的操作。如果是解释执行的过程中，比较好处理，找到对应的指令码，JVM就可以介入；但是在编译执行的时候，代码已经是01的机器码了，那就需要找到一个其它的手段来进行操作，这个就是"),_("code",[a._v("写屏障（Write Barrier）")])]),a._v(" "),_("p",[a._v("写屏障可以看做是在虚拟机层面对“引用字段赋值”的AOP切面，在引用对象赋值时会产生一个环绕通知，赋值前的通知是写前屏障，赋值后的通知是写后屏障。在G1之前的垃圾收集器使用的都是写好屏障，也就是先更新引用关系，然后在写好屏障内更新卡表状态；")]),a._v(" "),_("div",{staticClass:"language-java line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token function"}},[a._v("oop_field_store")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("oop"),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v("field"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" oop new_value"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v(" \n    "),_("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 引用字段赋值操作 ")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v("field "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" new_value"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" \n    "),_("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 写后屏障，在这里完成卡表状态更新 ,")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token function"}},[a._v("post_write_barrier")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("field"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" new_value"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" \n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[a._v("1")]),_("br"),_("span",{staticClass:"line-number"},[a._v("2")]),_("br"),_("span",{staticClass:"line-number"},[a._v("3")]),_("br"),_("span",{staticClass:"line-number"},[a._v("4")]),_("br"),_("span",{staticClass:"line-number"},[a._v("5")]),_("br"),_("span",{staticClass:"line-number"},[a._v("6")]),_("br")])]),_("h6",{attrs:{id:"_3-2-1-3、伪共享"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-1-3、伪共享"}},[a._v("#")]),a._v(" 3.2.1.3、伪共享")]),a._v(" "),_("p",[a._v("伪共享是并发底层需要考虑的问题，因为现代CPU是使用"),_("code",[a._v("缓存行")]),a._v("(Cache Line)为单位进行存储的，如果并发情况下，多线程处理的变量恰好共享一个缓存行，那么就会互相影响导致性能降低，这就是伪共享问题。")]),a._v(" "),_("p",[a._v("如何避免或者优化，待补充.......")]),a._v(" "),_("h5",{attrs:{id:"_3-2-2、标记清除算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-2、标记清除算法"}},[a._v("#")]),a._v(" 3.2.2、标记清除算法")]),a._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/image-20231226145624640.png",alt:"image-20231226145624640"}})]),a._v(" "),_("p",[a._v("分为标记和清除两个步骤：")]),a._v(" "),_("ul",[_("li",[a._v("首先标记出需要回收的对象（即垃圾对象）")]),a._v(" "),_("li",[a._v("统一回收所有标记的对象")])]),a._v(" "),_("p",[a._v("优点：简单")]),a._v(" "),_("p",[a._v("缺点：")]),a._v(" "),_("p",[a._v("1、不稳定，存在大量需要回收的对象时，必须进行大量的标记和清除工作，执行效率会随着对象数量的增高而降低")]),a._v(" "),_("p",[a._v("2、导致内存碎片问题，碎片太多会导致无法进行大对象的存储，而触发下一次的垃圾回收")]),a._v(" "),_("h5",{attrs:{id:"_3-2-3、标记复制算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-3、标记复制算法"}},[a._v("#")]),a._v(" 3.2.3、标记复制算法")]),a._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/image-20231226150237777.png",alt:"image-20231226150237777"}})]),a._v(" "),_("p",[a._v("将可用内存按照容量分为大小相等的两块，每次只使用其中的一块，当其中一块的内存使用完了，就将还存活的对象复制到另一块上面，然后把已使用的那一块内存整体进行清除")]),a._v(" "),_("p",[a._v("优点：不会产生内存碎片、效率高")]),a._v(" "),_("p",[a._v("缺点：浪费内存空间")]),a._v(" "),_("h5",{attrs:{id:"_3-2-4、标记整理算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-4、标记整理算法"}},[a._v("#")]),a._v(" 3.2.4、标记整理算法")]),a._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/image-20231226152452113.png",alt:"image-20231226152452113"}})]),a._v(" "),_("p",[a._v("分为标记-整理两个阶段")]),a._v(" "),_("ul",[_("li",[a._v("首先标记出需要回收的对象（即垃圾对象）")]),a._v(" "),_("li",[a._v("让所有存活对象都向内存一侧移动，然后清理掉边界以外的内存")])]),a._v(" "),_("p",[a._v("优点是解决了内存碎片问题")]),a._v(" "),_("p",[a._v("缺点是需要更新对象的引用，并且这种移动需要停止用户线程，也就是STW（Stop The Word）")]),a._v(" "),_("h4",{attrs:{id:"_3-3、安全点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-3、安全点"}},[a._v("#")]),a._v(" 3.3、安全点")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("问题1：为什么需要安全点？解决了什么问题？")]),a._v(" "),_("p",[a._v("不论是什么垃圾收集器，在GCRoots枚举期间（也就是确定具体哪些对象可以放在GCRoots中）都是需要STW的，那么如何减少这一段的STW时间就至关重要了，HotSpot 虚拟机使用了一组OopMap的数据结构来存储了哪些地方存在这些引用。一旦类加载完成，HotSpot就会把对象内偏移量上是什么类型的数据计算出来，在即时编译中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样的话垃圾收集器在扫描的时候就可以知道这些信息，而不用全量的扫描方法区等地方去查找GCRoots了。")])]),a._v(" "),_("li",[_("p",[a._v("问题2：有了OopMap那么还会有什么问题？")]),a._v(" "),_("p",[a._v("因为真实的代码中引起关联关系变化的地方非常多，如果每一个指令都会生成对应的OopMap，那将会占用大量的空间，那么解决方案就是只有在特定的地方才会生成OopMap，这些位置就是"),_("code",[a._v("安全点")])]),a._v(" "),_("p",[a._v("有了安全点之后，用户程序并不是在任意的代码指令行都可以停止进行垃圾收集，而是强制要求执行安全点后才会停止。")])]),a._v(" "),_("li",[_("p",[a._v("问题3：什么指令会成为安全点：")]),a._v(" "),_("p",[a._v("安全点位置的选取基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的。所以，方法调用、循环跳转、异常跳转等都属于指令复用，这些功能的指令才会产生安全点")])]),a._v(" "),_("li",[_("p",[a._v("问题4：发生GC时，如何让所有线程都跑到最近的安全点停顿下来？")]),a._v(" "),_("p",[a._v("HotSpot使用的主动式中断思想，就是当垃圾收集器需要中断线程的时候，不直接对线程操作，而是简单的设置一个标志，每个线程在运行过程中需要不停的去主动轮训这个标志，一旦发现中断标志位真时，就在离自己最近的安全点主动挂起。")])])]),a._v(" "),_("h4",{attrs:{id:"_3-4、安全区域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-4、安全区域"}},[a._v("#")]),a._v(" 3.4、安全区域")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("问题1：为什么引入安全区域？")]),a._v(" "),_("p",[a._v("安全点解决了大部分问题，但是如果遇到了线程“不执行”的状态怎么办？比如线程Sleep状态、Blocked状态，这时候线程无法响应虚拟机的中断请求，虚拟机也不可能等待线程这么长的时间，这种情况就必须引入安全区域的概念")]),a._v(" "),_("p",[a._v("安全区域能够确保在某一段代码片段之中，引用关系不会变化，因此，在这一区域的任意时间开始垃圾收集都是安全的")])]),a._v(" "),_("li",[_("p",[a._v("问题2：如何解决上述问题？")]),a._v(" "),_("p",[a._v("当用户线程进入安全区域的代码时，会首先标识自己已经进入了安全区域，那么当这段时间内虚拟机要发生垃圾收集时，就不必去管这些已经声明在安全区域的线程了（上述问题，因为线程Sleep状态或者锁定状态，那么这段时间内引用关系不会发生变化，那么此线程就处于安全区域了）。当线程要离开安全区域时，要检查虚拟机是否完成了根节点的枚举过程，如果完成了，那么此线程可以继续运行，如果没有完成，那么线程必须一直等待直到收到可以离开安全区域的信号为止")])])]),a._v(" "),_("h4",{attrs:{id:"_3-5、三色标记"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-5、三色标记"}},[a._v("#")]),a._v(" 3.5、三色标记")]),a._v(" "),_("p",[a._v("在扫描遍历中遇到的对象，按照是否访问过分为三种颜色：")]),a._v(" "),_("ul",[_("li",[a._v("白色：从未被访问过")]),a._v(" "),_("li",[a._v("黑色：已经被访问过，并且当前对象的所有引用都被访问过")]),a._v(" "),_("li",[a._v("灰色：已经被访问过，但是当前对象至少还有一个引用没有被访问")])]),a._v(" "),_("p",[a._v("三色标记在用户线程和收集线程同时工作的情况下，会出现严重的错误标记问题！")]),a._v(" "),_("p",[a._v("产生原因：以下两种情况同时存在会出现错误标记问题")]),a._v(" "),_("ul",[_("li",[a._v("用户线程增加了一个或者多个黑色到白色对象的引用")]),a._v(" "),_("li",[a._v("用户线程删除了全部灰色对象到该白色对象的直接或者间接引用")])]),a._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/image-20231227161312780.png",alt:"image-20231227161312780"}})]),a._v(" "),_("hr"),a._v(" "),_("p",[a._v("如何解决：")]),a._v(" "),_("p",[a._v("两种情况同时存在才会出现错误标记，对应的只需要处理一种情况就可以解决错误标记问题，那么对应的就会出现两种解决方案")]),a._v(" "),_("p",[a._v("1、增量更新(Incremental Update)")]),a._v(" "),_("p",[a._v("​\t\t增量更新破坏的是第一个条件，当黑色对象增加了对于白色对象的引用，那就把这个新增加的引用记录下来，等并发扫描结束后，再将这些记录过的引用关系中的黑色对象为根节点，重新扫描一次。（CMS使用）")]),a._v(" "),_("p",[a._v("2、原始快照(Snapshot At The Beginning， SATB)")]),a._v(" "),_("p",[a._v("​\t\t原始快照破坏的是第二个条件，当灰色对象删除指向白色对象的引用时，将这个删除的引用记录下来，在并发扫描结束后，将记录中引用关系中的灰色对象为根对象，重新扫描一次。（G1使用）")]),a._v(" "),_("h3",{attrs:{id:"_4、垃圾收集器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4、垃圾收集器"}},[a._v("#")]),a._v(" 4、垃圾收集器")]),a._v(" "),_("h4",{attrs:{id:"_4-1、cms"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-1、cms"}},[a._v("#")]),a._v(" 4.1、CMS")]),a._v(" "),_("p",[a._v("CMS（Concurrent Mark Sweep）是以获取最短停顿时间为目标的收集器，使用的标记清除算法，会产生内存碎片")]),a._v(" "),_("p",[a._v("整个收集过程分为四个步骤：")]),a._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/image-20231227163524330.png",alt:"image-20231227163524330"}})]),a._v(" "),_("p",[a._v("1、初始标记（需要STW）\n仅仅只标记RCRoot能直接关联的对象，时间比较快")]),a._v(" "),_("p",[a._v("2、并发标记（用户线程并发）\n耗时较长，但是能用户线程并发")]),a._v(" "),_("p",[a._v("3、重新标记（需要STW）")]),a._v(" "),_("p",[a._v("​\t\t修正并发标记期间错误标记的对象（也就是解决三色标记错标的增量更新过程）")]),a._v(" "),_("p",[a._v("4、并发清除（用户线程并发）")]),a._v(" "),_("p",[a._v("​\t\t清除标记过程中为垃圾的对象")]),a._v(" "),_("hr"),a._v(" "),_("p",[a._v("CMS的缺点：")]),a._v(" "),_("p",[a._v("1、CMS是一块吃处理器资源的收集器，默认开启的垃圾收集线程数量是：（处理器核心数量+3）/4")]),a._v(" "),_("p",[a._v("2、浮动垃圾问题。CMS并发标记和并发清除期间，用户线程依旧在运行，也就是说这一段时间依然在产生的新的垃圾对象，但是这些对象只有等待下次GC的时候才能被标记和清除，这些对象就称之为浮动垃圾。浮动垃圾生产的速度如果超过了GC清除的速度，那么就会产生"),_("strong",[a._v("并发失败")]),_("code",[a._v("“Concurrent Mode Failure”而导致一次完全STW的FULL GC")]),a._v("，这一次的FULL GC是Serial Old 收集器在执行接管。相关的参数如下：")]),a._v(" "),_("div",{staticClass:"language-shell line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-shell"}},[_("code",[a._v("设置多大比例后触发CMS垃圾收集\n-XX： CMSInitiatingOccupancyFraction  \n")])]),a._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[a._v("1")]),_("br"),_("span",{staticClass:"line-number"},[a._v("2")]),_("br")])]),_("p",[a._v("3、内存碎片问题。内存碎片过多会提前触发FULL GC，解决方案涉及两个参数（JDK9废除了这两个参数）")]),a._v(" "),_("div",{staticClass:"language-shell line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-shell"}},[_("code",[a._v("默认开启，CMS 收集器不得不进行 Full GC 时开启内存碎片的合并整理过程（STW时间会加长）\n-XX：+UseCMSCompactAtFullCollection\nCMS 收集器在执行过若干次（数量由参数值决定）不整理空间的 Full GC 之后，下一次进入 Full GC 前会先进行碎片整理（默认值为 "),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("，表示每次进入 Full GC 时都进行碎片整理）\n-XX：CMSFullGCsBeforeCompaction\n")])]),a._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[a._v("1")]),_("br"),_("span",{staticClass:"line-number"},[a._v("2")]),_("br"),_("span",{staticClass:"line-number"},[a._v("3")]),_("br"),_("span",{staticClass:"line-number"},[a._v("4")]),_("br")])]),_("h4",{attrs:{id:"_4-2、g1"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-2、g1"}},[a._v("#")]),a._v(" 4.2、G1")])])}),[],!1,null,null,null);t.default=s.exports}}]);