(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{335:function(v,_,t){"use strict";t.r(_);var s=t(8),i=Object(s.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"linux-系统监测命令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#linux-系统监测命令"}},[v._v("#")]),v._v(" Linux-系统监测命令")]),v._v(" "),_("h2",{attrs:{id:"_1、tcpdump"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、tcpdump"}},[v._v("#")]),v._v(" 1、tcpdump")]),v._v(" "),_("blockquote",[_("p",[v._v("tcpdump给使用者提供了大量的选项，用以过滤数据包或者定制输出格式")])]),v._v(" "),_("ul",[_("li",[v._v("-n，使用IP地址表示主机，而不是主机名；使用数字表示端口号，而不是服务名称")]),v._v(" "),_("li",[v._v("-i，指定要监听的网卡接口。“-i any”表示抓取所有网卡接口上的数据包")]),v._v(" "),_("li",[v._v("-v，输出一个稍微详细的信息，例如，显示IP数据包中的TTL和TOS信息")]),v._v(" "),_("li",[v._v("-t，不打印时间戳")]),v._v(" "),_("li",[v._v("-e，显示以太网帧头部信息。")]),v._v(" "),_("li",[v._v("-c，仅抓取指定数量的数据包")]),v._v(" "),_("li",[v._v("-x，以十六进制数显示数据包的内容，但不显示包中以太网帧的头部信息。")]),v._v(" "),_("li",[v._v("-X，与-x选项类似，不过还打印每个十六进制字节对应的ASCII字符")]),v._v(" "),_("li",[v._v("-XX，与-X相同，不过还打印以太网帧的头部信息")]),v._v(" "),_("li",[v._v("-s，设置抓包时的抓取长度。当数据包的长度超过抓取长度时，tcpdump抓取到的将是被截断的数据包。在4.0以及之前的版本中，默认的抓包长度是68字节。这对于IP、TCP和UDP等协议就已经足够了，但对于像DNS、NFS这样的协议，68字节通常不能容纳一个完整的数据包。不过4.0之后的版本，默认的抓包长度被修改为65 535字节，因此我们不用再担心抓包长度的问题了")]),v._v(" "),_("li",[v._v("-S，以绝对值来显示TCP报文段的序号，而不是相对值")]),v._v(" "),_("li",[v._v("-w，将tcpdump的输出以特殊的格式定向到某个文件")]),v._v(" "),_("li",[v._v("-r，从文件读取数据包信息并显示之")])]),v._v(" "),_("hr"),v._v(" "),_("p",[v._v("除了使用选项外，tcpdump还支持用表达式来进一步过滤数据包。tcpdump表达式的操作数分为3种：类型（type）、方向（dir）和协议（proto）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("类型，解释其后面紧跟着的参数的含义。tcpdump支持的类型包括host、net、port和portrange。它们分别指定主机名（或IP地址），用CIDR方法表示的网络地址，端口号以及端口范围。比如，要抓取整个1.2.3.0/255.255.255.0网络上的数据包，可以使用如下命令：")]),v._v(" "),_("p",[v._v("$tcpdump net 1.2.3.0/24")])]),v._v(" "),_("li",[_("p",[v._v("方向，src指定数据包的发送端，dst指定数据包的目的端。比如要抓取进入端口13579的数据包，可以使用如下命令：")]),v._v(" "),_("p",[v._v("$tcpdump dst port 13579")])]),v._v(" "),_("li",[_("p",[v._v("协议，指定目标协议。比如要抓取所有ICMP数据包，可以使用如下命令：")]),v._v(" "),_("p",[v._v("$tcpdump icmp")])])]),v._v(" "),_("hr"),v._v(" "),_("p",[v._v("我们还可以使用逻辑操作符来组织上述操作数以创建更复杂的表达式。tcpdump支持的逻辑操作符和编程语言中的逻辑操作符完全相同，包括and（或者＆＆）、or（或者||）、not（或者!）。比如要抓取主机ernest-laptop和所有非Kongming20的主机之间交换的IP数据包，可以使用如下命令：")]),v._v(" "),_("p",[v._v("$tcpdump ip host ernest-laptop and not Kongming20")]),v._v(" "),_("h2",{attrs:{id:"_2、lsof"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、lsof"}},[v._v("#")]),v._v(" 2、lsof")]),v._v(" "),_("blockquote",[_("p",[v._v("lsof（list open file）是一个列出当前系统打开的文件描述符的工具。通过它我们可以了解感兴趣的进程打开了哪些文件描述符，或者我们感兴趣的文件描述符被哪些进程打开了")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("-i，显示socket文件描述符。该选项的使用方法是")]),v._v(" "),_("p",[v._v("$lsof-i[46][protocol][@hostname|ipaddr][:service|port]")]),v._v(" "),_("p",[v._v("其中，4表示IPv4协议，6表示IPv6协议；protocol指定传输层协议，可以是TCP或者UDP；hostname指定主机名；ipaddr指定主机的IP地址；service指定服务名；port指定端口号。比如，要显示所有连接到主机192.168.1.108的ssh服务的socket文件描述符，可以使用命令：")]),v._v(" "),_("p",[v._v("$lsof-i@192.168.1.108:22")]),v._v(" "),_("p",[v._v("如果-i选项后不指定任何参数，则lsof命令将显示所有socket文件描述符")])]),v._v(" "),_("li",[_("p",[v._v("-u，显示指定用户启动的所有进程打开的所有文件描述符")])]),v._v(" "),_("li",[_("p",[v._v("-c，显示指定的命令打开的所有文件描述符。")]),v._v(" "),_("p",[v._v("比如要查看websrv程序打开了哪些文件描述符，可以使用如下命令：")]),v._v(" "),_("p",[v._v("$lsof-c websrv")])]),v._v(" "),_("li",[_("p",[v._v("-p，显示指定进程打开的所有文件描述符")])]),v._v(" "),_("li",[_("p",[v._v("-t，仅显示打开了目标文件描述符的进程的PID")])])]),v._v(" "),_("hr"),v._v(" "),_("p",[v._v("lsof命令的输出内容相当丰富，其中每行内容都包含如下字段:")]),v._v(" "),_("ul",[_("li",[v._v("COMMAND，执行程序所使用的终端命令（默认仅显示前9个字符)")]),v._v(" "),_("li",[v._v("PID，文件描述符所属进程的PID。")]),v._v(" "),_("li",[v._v("USER，拥有该文件描述符的用户的用户名。")]),v._v(" "),_("li",[v._v("FD，文件描述符的描述。其中cwd表示进程的工作目录，rtd表示用户的根目录，txt表示进程运行的程序代码，mem表示直接映射到内存中的文件（本例中都是动态库）。有的FD是以“数字+访问权限”表示的，其中数字是文件描述符的具体数值，访问权限包括r（可读）、w（可写）和u（可读可写）")]),v._v(" "),_("li",[v._v("TYPE，文件描述符的类型。其中DIR是目录，REG是普通文件，CHR是字符设备文件，IPv4是IPv4类型的socket文件描述符，0000是未知类型")]),v._v(" "),_("li",[v._v("DEVICE，文件所属设备。对于字符设备和块设备，其表示方法是“主设备号，次设备号”。")]),v._v(" "),_("li",[v._v("SIZE/OFF，文件大小或者偏移值。如果该字段显示为“0t*”或者“0x*”，就表示这是一个偏移值，否则就表示这是一个文件大小")]),v._v(" "),_("li",[v._v("NODE，文件的i节点号。对于socket，则显示为协议类型，比如“TCP“")]),v._v(" "),_("li",[v._v("NAME，文件的名字。")])]),v._v(" "),_("h2",{attrs:{id:"_3、nc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3、nc"}},[v._v("#")]),v._v(" 3、nc")]),v._v(" "),_("blockquote",[_("p",[v._v("nc（netcat）命令短小精干、功能强大，有着“瑞士军刀”的美誉。")]),v._v(" "),_("p",[v._v("它主要被用来快速构建网络连接。我们可以让它以服务器方式运行，监听某个端口并接收客户连接，因此它可用来调试客户端程序。我们也可以使之以客户端方式运行，向服务器发起连接并收发数据，因此它可以用来调试服务器程序，此时它有点像telnet程序")])]),v._v(" "),_("ul",[_("li",[v._v("-i，设置数据包传送的时间间隔")]),v._v(" "),_("li",[v._v("-l，以服务器方式运行，监听指定的端口。nc命令默认以客户端方式运行")]),v._v(" "),_("li",[v._v("-k，重复接受并处理某个端口上的所有连接，必须与-l选项一起使用")]),v._v(" "),_("li",[v._v("-n，使用IP地址表示主机，而不是主机名；使用数字表示端口号，而不是服务名称。")]),v._v(" "),_("li",[v._v("-p，当nc命令以客户端方式运行时，强制其使用指定的端口号")]),v._v(" "),_("li",[v._v("-s，设置本地主机发送出的数据包的IP地址。")]),v._v(" "),_("li",[v._v("-C，将CR和LF两个字符作为行结束符")]),v._v(" "),_("li",[v._v("-U，使用UNIX本地域协议通信")]),v._v(" "),_("li",[v._v("-u，使用UDP协议。nc命令默认使用的传输层协议是TCP协议")]),v._v(" "),_("li",[v._v("-w，如果nc客户端在指定的时间内未检测到任何输入，则退出")]),v._v(" "),_("li",[v._v("-X，当nc客户端和代理服务器通信时，该选项指定它们之间使用的通信协议。目前nc支持的代理协议包括“4”（SOCKSv.4），“5”（SOCKS v.5）和“connect”（HTTPS proxy）。nc默认使用的代理协议是SOCKS v.5")]),v._v(" "),_("li",[v._v("-x，指定目标代理服务器的IP地址和端口号")]),v._v(" "),_("li",[v._v("-z，扫描目标机器上的某个或某些服务是否开启（端口扫描）")])]),v._v(" "),_("p",[v._v("举例来说，我们可以使用如下方式来连接websrv服务器并向它发送数据")]),v._v(" "),_("p",[v._v("$nc-C 127.0.0.1 13579（服务器监听端口13579）GET http://localhost/a.htmlHTTP/1.1（回车）Host:localhost（回车）（回车）HTTP/1.1 404 Not FoundContent-Length:49Connection:closeThe requested file was not found onthis server.")]),v._v(" "),_("h2",{attrs:{id:"_4、strace"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4、strace"}},[v._v("#")]),v._v(" 4、strace")]),v._v(" "),_("blockquote",[_("p",[v._v("strace是测试服务器性能的重要工具。它跟踪程序运行过程中执行的系统调用和接收到的信号，并将系统调用名、参数、返回值及信号名输出到标准输出或者指定的文件。")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("-c，统计每个系统调用执行时间、执行次数和出错次数")])]),v._v(" "),_("li",[_("p",[v._v("-f，跟踪由fork调用生成的子进程")])]),v._v(" "),_("li",[_("p",[v._v("-t，在输出的每一行信息前加上时间信息。")])]),v._v(" "),_("li",[_("p",[v._v("-e，指定一个表达式，用来控制如何跟踪系统调用（或接收到的信号，下同）。其格式是")]),v._v(" "),_("p",[v._v("[qualifier=][!]value1[,value2]...")]),v._v(" "),_("ul",[_("li",[v._v("-e trace=set，只跟踪指定的系统调用。例如，-e trace=open，close，read，write表示只跟踪open、close、read和write这四种系统调用")]),v._v(" "),_("li",[v._v("-e trace=file，只跟踪与文件操作相关的系统调用")]),v._v(" "),_("li",[v._v("-e trace=process，只跟踪与进程控制相关的系统调用")]),v._v(" "),_("li",[v._v("-e trace=network，只跟踪与网络相关的系统调用")])])]),v._v(" "),_("li",[_("p",[v._v("-o，将strace的输出写入指定的文件")])])]),v._v(" "),_("h2",{attrs:{id:"_5、netstat"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5、netstat"}},[v._v("#")]),v._v(" 5、netstat")]),v._v(" "),_("blockquote",[_("p",[v._v("netstat是一个功能很强大的网络信息统计工具。它可以打印本地网卡接口上的全部连接、路由表信息、网卡接口信息等")])]),v._v(" "),_("ul",[_("li",[v._v("-n，使用IP地址表示主机，而不是主机名；使用数字表示端口号，而不是服务名称")]),v._v(" "),_("li",[v._v("-a，显示结果中也包含监听socket")]),v._v(" "),_("li",[v._v("-t，仅显示TCP连接")]),v._v(" "),_("li",[v._v("-r，显示路由信息")]),v._v(" "),_("li",[v._v("-i，显示网卡接口的数据流量")]),v._v(" "),_("li",[v._v("-c，每隔1 s输出一次")]),v._v(" "),_("li",[v._v("-o，显示socket定时器（比如保活定时器）的信息")]),v._v(" "),_("li",[v._v("-p，显示socket所属的进程的PID和名字")])]),v._v(" "),_("hr"),v._v(" "),_("p",[v._v("netstat的每行输出都包含如下6个字段（默认情况）")]),v._v(" "),_("ul",[_("li",[v._v("Proto，协议名")]),v._v(" "),_("li",[v._v("Recv-Q，socket内核接收缓冲区中尚未被应用程序读取的数据量")]),v._v(" "),_("li",[v._v("Send-Q，未被对方确认的数据量")]),v._v(" "),_("li",[v._v("Local Address，本端的IP地址和端口号。")]),v._v(" "),_("li",[v._v("Foreign Address，对方的IP地址和端口号。")]),v._v(" "),_("li",[v._v("State，socket的状态。对于无状态协议，比如UDP协议，这一字段将显示为空。而对面向连接的协议而言，netstat支持的State包括ESTABLISHED、SYN_SENT、SYN_RCVD、FIN_WAIT1、FIN_WAIT2、TIME_WAIT、CLOSE、CLOSE_WAIT、LAST_ACK、LISTEN、CLOSING、UNKNOWN")])]),v._v(" "),_("h2",{attrs:{id:"_6、vmstat"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6、vmstat"}},[v._v("#")]),v._v(" 6、vmstat")]),v._v(" "),_("blockquote",[_("p",[v._v("vmstat是virtual memory statistics的缩写，它能实时输出系统的各种资源的使用情况，比如进程信息、内存使用、CPU使用率以及I/O使用情况")])]),v._v(" "),_("ul",[_("li",[v._v("-f，显示系统自启动以来执行的fork次数")]),v._v(" "),_("li",[v._v("-s，显示内存相关的统计信息以及多种系统活动的数量（比如CPU上下文切换次数）")]),v._v(" "),_("li",[v._v("-d，显示磁盘相关的统计信息。")]),v._v(" "),_("li",[v._v("-p，显示指定磁盘分区的统计信息。")]),v._v(" "),_("li",[v._v("-S，使用指定的单位来显示。参数k、K、m、M分别代表1000、1024、1 000000和1 048 576字节")]),v._v(" "),_("li",[v._v("delay，采样间隔（单位是s），即每隔delay的时间输出一次统计信息。")]),v._v(" "),_("li",[v._v("count，采样次数，即共输出count次统计信息。")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/image-20240428153911712.png",alt:"image-20240428153911712"}})]),v._v(" "),_("p",[v._v("输出结果：")]),v._v(" "),_("ul",[_("li",[v._v("procs，进程信息。“r”表示等待运行的进程数目；“b”表示处于不可中断睡眠状态的进程数目。")]),v._v(" "),_("li",[v._v("memory，内存信息，各项的单位都是千字节（KB）。“swpd”表示虚拟内存的使用数量。“free”表示空闲内存的数量。“buff”表示作为“buffer cache”的内存数量。从磁盘读入的数据可能被保持在“buffercache”中，以便下一次快速访问。“cache”表示作为“page cache”的内存数量。待写入磁盘的数据将首先被放到“page cache”中，然后由磁盘中断程序写入磁盘")]),v._v(" "),_("li",[v._v("swap，交换分区（虚拟内存）的使用信息，各项的单位都是KB/s。“si”表示数据由磁盘交换至内存的速率；“so”表示数据由内存交换至磁盘的速率。如果这两个值经常发生变化，则说明内存不足。")]),v._v(" "),_("li",[v._v("io，块设备的使用信息，单位是block/s。“bi”表示从块设备读入块的速率；“bo”表示向块设备写入块的速率")]),v._v(" "),_("li",[v._v("system，系统信息。“in”表示每秒发生的中断次数；“cs”表示每秒发生的上下文切换（进程切换）次数。")]),v._v(" "),_("li",[v._v("cpu，CPU使用信息。“us”表示系统所有进程运行在用户空间的时间占CPU总运行时间的比例；“sy”表示系统所有进程运行在内核空间的时间占CPU总运行时间的比例；“id”表示CPU处于空闲状态的时间占CPU总运行时间的比例；“wa”表示CPU等待I/O事件的时间占CPU总运行时间的比例")])]),v._v(" "),_("h2",{attrs:{id:"_7、ifstat"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7、ifstat"}},[v._v("#")]),v._v(" 7、ifstat")]),v._v(" "),_("blockquote",[_("p",[v._v("ifstat是interface statistics的缩写，它是一个简单的网络流量监测工具")])]),v._v(" "),_("ul",[_("li",[v._v("-a，监测系统上的所有网卡接口")]),v._v(" "),_("li",[v._v("-i，指定要监测的网卡接口。")]),v._v(" "),_("li",[v._v("-t，在每行输出信息前加上时间戳")]),v._v(" "),_("li",[v._v("-b，以Kbit/s为单位显示数据，而不是默认的KB/s。")]),v._v(" "),_("li",[v._v("delay，采样间隔（单位是s），即每隔delay的时间输出一次统计信息。")]),v._v(" "),_("li",[v._v("count，采样次数，即共输出count次统计信息。")])]),v._v(" "),_("h2",{attrs:{id:"_8、mpstat"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8、mpstat"}},[v._v("#")]),v._v(" 8、mpstat")]),v._v(" "),_("blockquote",[_("p",[v._v("mpstat是multi-processor statistics的缩写，它能实时监测多处理器系统上每个CPU的使用情况。mpstat命令和iostat命令通常都集成在包sysstat中，安装sysstat即可获得这两个命令。")])]),v._v(" "),_("p",[v._v("mpstat命令的典型用法是（mpstat命令的选项不多，这里不再专门介绍）：")]),v._v(" "),_("p",[v._v("mpstat[-P{|ALL}][interval[count]]")]),v._v(" "),_("p",[v._v("选项P指定要监控的CPU号（0～CPU个数-1），其值“ALL”表示监听所有的CPU。interval参数是采样间隔（单位是s），即每隔interval的时间输出一次统计信息。count参数是采样次数，即共输出count次统计信息，但mpstat最后还会输出这count次采样结果的平均值。与vmstat命令一样，mpstat命令输出的第一次结果是自系统启动以来的平均结果，而后面（count-1）次输出结果则是采样间隔内的平均结果")]),v._v(" "),_("p",[v._v("每条信息都包含如下几个字段：")]),v._v(" "),_("ul",[_("li",[v._v("CPU，指示该条信息是哪个CPU的数据。“0”表示是第1个CPU的数据，“1”表示是第2个CPU的数据，“all”则表示是这两个CPU数据的平均值")]),v._v(" "),_("li",[v._v("%usr，除了nice值为负的进程，系统上其他进程运行在用户空间的时间占CPU总运行时间的比例。")]),v._v(" "),_("li",[v._v("%nice，nice值为负的进程运行在用户空间的时间占CPU总运行时间的比例。")]),v._v(" "),_("li",[v._v("%sys，系统上所有进程运行在内核空间的时间占CPU总运行时间的比例，但不包括硬件和软件中断消耗的CPU时间。")]),v._v(" "),_("li",[v._v("%iowait，CPU等待磁盘操作的时间占CPU总运行时间的比例。")]),v._v(" "),_("li",[v._v("%irq，CPU用于处理硬件中断的时间占CPU总运行时间的比例。")]),v._v(" "),_("li",[v._v("%soft，CPU用于处理软件中断的时间占CPU总运行时间的比例。")]),v._v(" "),_("li",[v._v("%steal，一个物理CPU可以包含一对虚拟CPU，这一对虚拟CPU由超级管理程序管理。当超级管理程序在处理某个虚拟CPU时，另外一个虚拟CPU则必须等待它处理完成才能运行。这部分等待时间就是所谓的steal时间。该字段表示steal时间占CPU总运行时间的比例")]),v._v(" "),_("li",[v._v("%guest，运行虚拟CPU的时间占CPU总运行时间的比例。")]),v._v(" "),_("li",[v._v("%idle，系统空闲的时间占CPU总运行时间的比例。")])]),v._v(" "),_("p",[_("code",[v._v("在所有这些输出字段中，我们最关心的是%user、%sys和%idle。它们基本上反映了我们的代码中业务逻辑代码和系统调用所占的比例，以及系统还能承受多大的负载")])])])}),[],!1,null,null,null);_.default=i.exports}}]);