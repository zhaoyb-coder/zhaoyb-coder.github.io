(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{334:function(t,_,e){"use strict";e.r(_);var v=e(8),a=Object(v.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"linux-网络模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#linux-网络模型"}},[t._v("#")]),t._v(" Linux-网络模型")]),t._v(" "),_("hr"),t._v(" "),_("h2",{attrs:{id:"_1、服务器基本框架"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、服务器基本框架"}},[t._v("#")]),t._v(" 1、服务器基本框架")]),t._v(" "),_("blockquote",[_("p",[t._v("虽然服务器程序种类繁多，但其基本框架都一样，不同之处在于逻辑处理")])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/image-20240304164613566.png",alt:"image-20240304164613566"}})]),t._v(" "),_("p",[_("code",[t._v("IO处理单元")]),t._v("是服务器管理客户连接的模块")]),t._v(" "),_("p",[t._v("它通常要完成以下工作：等待并接受新的客户连接，接收客户数据，将服务器响应数据返回给客户端。但是，数据的收发不一定在I/O处理单元中执行，也可能在逻辑单元中执行，具体在何处执行取决于事件处理模式。对于一个服务器机群来说，I/O处理单元是一个专门的接入服务器。它实现负载均衡，从所有逻辑服务器中选取负荷最小的一台来为新客户服务")]),t._v(" "),_("p",[_("code",[t._v("逻辑单元")]),t._v("通常是一个进程或线程。")]),t._v(" "),_("p",[t._v("它分析并处理客户数据，然后将结果传递给I/O处理单元或者直接发送给客户端（具体使用哪种方式取决于事件处理模式）。对服务器机群而言，一个逻辑单元本身就是一台逻辑服务器。服务器通常拥有多个逻辑单元，以实现对多个客户任务的并行处理")]),t._v(" "),_("p",[_("code",[t._v("网络存储单元")]),t._v("可以是数据库、缓存和文件，甚至是一台独立的服务器。但它不是必须的，比如ssh、telnet等登录服务就不需要这个单元")]),t._v(" "),_("p",[_("code",[t._v("请求队列")]),t._v("是各单元之间的通信方式的抽象。I/O处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。同样，多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调处理竞态条件。请求队列通常被实现为池的一部分")]),t._v(" "),_("p",[t._v("对于服务器机群而言，请求队列是各台服务器之间预先建立的、静态的、永久的TCP连接。这种TCP连接能提高服务器之间交换数据的效率，因为它避免了动态建立TCP连接导致的额外的系统开销")]),t._v(" "),_("h2",{attrs:{id:"_2、服务器模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、服务器模型"}},[t._v("#")]),t._v(" 2、服务器模型")]),t._v(" "),_("h3",{attrs:{id:"_2-1、c-s模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1、c-s模型"}},[t._v("#")]),t._v(" 2.1、C/S模型")]),t._v(" "),_("blockquote",[_("p",[t._v("客户端/服务器模型")]),t._v(" "),_("p",[t._v("所有客户端都通过访问服务器来获取所需的资源")])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/image-20240304164850860.png",alt:"image-20240304164850860"}})]),t._v(" "),_("p",[_("strong",[t._v("C/S模型的TCP工作流程：")])]),t._v(" "),_("p",[t._v("C/S模型的逻辑很简单")]),t._v(" "),_("p",[t._v("服务启动后，首先创建一个或者多个监听socket，并调用bind函数将其绑定到服务器感兴趣的端口上；")]),t._v(" "),_("p",[t._v("然后调用listen函数等待客户端连接")]),t._v(" "),_("p",[t._v("服务器稳定运行之后，就要等待客户端调用connect函数向服务器发起连接，由于客户端的请求随机到达的异步事件，服务器需要某种IO模型来监听这一事件（select / poll / epoll ）,下图所示的就是select模型来处理")]),t._v(" "),_("p",[t._v("当监听到连接请求后，服务器就调用accept函数接受它，并分配一个逻辑单元处理，（逻辑单元可以是新的子进程、子线程等）")]),t._v(" "),_("p",[t._v("逻辑单元读取客户请求，处理该请求，然后将处理结果返回客户端")]),t._v(" "),_("p",[t._v("客户端接收到服务器的处理结果后，可以继续发送请求，也可以主动关闭连接，服务器则会被动关闭连接")]),t._v(" "),_("p",[t._v("至此，双方通信结束")]),t._v(" "),_("p",[t._v("优点就是实现简单，适合资源相对集中的场景")]),t._v(" "),_("p",[t._v("缺点就是访问量过大的时候效率过低，响应慢")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/image-20240304165022606.png",alt:"image-20240304165022606"}})]),t._v(" "),_("h3",{attrs:{id:"_2-2、p2p模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2、p2p模型"}},[t._v("#")]),t._v(" 2.2、P2P模型")]),t._v(" "),_("blockquote",[_("p",[t._v("P2P（Peer to Peer，点对点）模型比C/S模型更符合网络通信的实际情况。它摒弃了以服务器为中心的格局，让网络上所有主机重新回归对等的地位")]),t._v(" "),_("p",[t._v("P2P模型使得每台机器在消耗服务的同时也给别人提供服务，这样资源能够充分、自由地共享")]),t._v(" "),_("p",[t._v("从编程角度来讲，P2P模型可以看作C/S模型的扩展：每台主机既是客户端，又是服务器")])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/zhaoyb-coder/pic-repo/main/image-20240304165114357.png",alt:"image-20240304165114357"}})])])}),[],!1,null,null,null);_.default=a.exports}}]);