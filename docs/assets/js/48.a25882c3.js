(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{362:function(a,t,s){"use strict";s.r(t);var e=s(7),r=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"juc-文档"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#juc-文档"}},[a._v("#")]),a._v(" JUC 文档")]),a._v(" "),t("h2",{attrs:{id:"_1、线程池"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、线程池"}},[a._v("#")]),a._v(" 1、线程池")]),a._v(" "),t("h3",{attrs:{id:"_1、线程池参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、线程池参数"}},[a._v("#")]),a._v(" 1、线程池参数")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("corePoolSize")]),a._v(" "),t("blockquote",[t("p",[a._v("核心线程数")])])]),a._v(" "),t("li",[t("p",[a._v("maxPoolSize")]),a._v(" "),t("blockquote",[t("p",[a._v("最大线程数")])])]),a._v(" "),t("li",[t("p",[a._v("keepAliveTime")]),a._v(" "),t("blockquote",[t("p",[a._v("保持存活时间：如果当前的线程数corePoolSize，那么多余的线程空闲时间超过keepAliveTime，就会被终止")])])]),a._v(" "),t("li",[t("p",[a._v("workQueue")]),a._v(" "),t("blockquote",[t("p",[a._v("任务存储队列")])])]),a._v(" "),t("li",[t("p",[a._v("threadFactory")]),a._v(" "),t("blockquote",[t("p",[a._v("线程工厂，当线程池需要新的线程时，需要使用threadFactory创建新的新的线程，默认使用Excutors.defaultThreadFactory(),创建出来的线程都在同一个线程组，拥有同样的NORM_PRIORITY优先级，并且都不是守护线程，如果自己指定ThreadFactory，那么就可以改变线程组、线程名、优先级、是否守护线程等")])])]),a._v(" "),t("li",[t("p",[a._v("Handler")]),a._v(" "),t("blockquote",[t("p",[a._v("拒绝策略：任务过多时执行的拒绝策略，可以自定义")])])])]),a._v(" "),t("h3",{attrs:{id:"_2、jdk自带的线程池"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、jdk自带的线程池"}},[a._v("#")]),a._v(" 2、JDK自带的线程池")]),a._v(" "),t("h4",{attrs:{id:"_1、fixedthreadpool"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、fixedthreadpool"}},[a._v("#")]),a._v(" 1、FixedThreadPool")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Executors")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("newFixedThreadPool")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//参数为核心线程数，fixed线程池核心线程数和最大线程数一致")]),a._v("\n默认使用的是"),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("LinkedBlockingQueue")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Runnable")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("无界队列，队列没有长度限制，因为任务过多会导致任务积压，造成"),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("OOM")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br")])]),t("h4",{attrs:{id:"_2、singlethreadpool"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、singlethreadpool"}},[a._v("#")]),a._v(" 2、SingleThreadPool")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Executors")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("newSignleThreadExecutor")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//没有参数，当前线程池只会有一个线程存在，使用的队列也是LinkedBlockingQueue<>")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("h4",{attrs:{id:"_3、cachedthreadpool"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、cachedthreadpool"}},[a._v("#")]),a._v(" 3、CachedThreadPool")]),a._v(" "),t("blockquote",[t("p",[a._v("使用的队列是Synchronous queue ：属于直接交换的队列，内部无法存储任务，拿到任务之后直接交给线程处理")]),a._v(" "),t("p",[a._v("cached的特点就是能自动回收多余的线程，默认时间60s")])]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Executors")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("newCachedThreadPool")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//核心线程数是0，最大线程数是int的最大值，keepAliveTime默认60s")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br")])]),t("h4",{attrs:{id:"_4、scheduledthreadpool"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、scheduledthreadpool"}},[a._v("#")]),a._v(" 4、ScheduledThreadPool")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Executors")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("newScheduledThreadPool")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" coreThreadSize"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\nscheduledThreadPool"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("schedule")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Task")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("TimeUnit")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("SECONDS")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//代表这个线程池美格5s执行一次任务")]),a._v("\nscheduledThreadPool"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("scheduleAtFixedRate")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Task")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("TimeUnit")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("SECONDS")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//代表这个线程池第一个任务1s后执行，后需要的所有任务每隔三秒执行")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br")])]),t("h4",{attrs:{id:"_5、workstealingpool"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5、workstealingpool"}},[a._v("#")]),a._v(" 5、WorkStealingPool")]),a._v(" "),t("blockquote",[t("p",[a._v("JDK1.8新加入的线程池")]),a._v(" "),t("p",[a._v("子任务+窃取模式")])]),a._v(" "),t("h3",{attrs:{id:"_3、线程池中的线程数量多少合适"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、线程池中的线程数量多少合适"}},[a._v("#")]),a._v(" 3、线程池中的线程数量多少合适")]),a._v(" "),t("ul",[t("li",[a._v("CPU密集型（加密、Hash计算等）：最佳线程数为CPU核心线程的1-2倍")]),a._v(" "),t("li",[a._v("耗时IO型（读写数据库、文件、网络读写等）：最佳线程数一般是CPU核心数的很多倍，以JVM线程监控显示最繁忙情况的依据，保证线程空闲可以衔接上，")]),a._v(" "),t("li",[a._v("线程数=CPU核心数*（1+平均等待时间/平均工作时间）")])]),a._v(" "),t("h3",{attrs:{id:"_4、如何停止线程池"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、如何停止线程池"}},[a._v("#")]),a._v(" 4、如何停止线程池")]),a._v(" "),t("h4",{attrs:{id:"_1、shutdown"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、shutdown"}},[a._v("#")]),a._v(" 1、shutdown")]),a._v(" "),t("blockquote",[t("p",[a._v("Shutdown()方法执行之后，线程池不再接收新的任务（放入新任务会抛出异常），然后继续执行已经接收到的任务以及任务队列中的任务，直到所有任务执行完毕，线程池停止")])]),a._v(" "),t("h4",{attrs:{id:"_2、isshutdown"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、isshutdown"}},[a._v("#")]),a._v(" 2、isShutDown")]),a._v(" "),t("blockquote",[t("p",[a._v("isShutDown方法会返回当前线程池是否已经是执行过Shutdown方法了，返回值为boolean类型")])]),a._v(" "),t("h4",{attrs:{id:"_3、isterminated"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、isterminated"}},[a._v("#")]),a._v(" 3、isTerminated")]),a._v(" "),t("blockquote",[t("p",[a._v("返回当前线程池是否真正的停止，返回类型boolean值")])]),a._v(" "),t("h4",{attrs:{id:"_4、awaittermination"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、awaittermination"}},[a._v("#")]),a._v(" 4、awaitTermination")]),a._v(" "),t("blockquote",[t("p",[a._v("判断当前线程池是否以终止")]),a._v(" "),t("p",[a._v("threadPool.awaitTermination(3L,TimeUnit.SECONDS);")]),a._v(" "),t("p",[a._v("//这行代码意思是阻塞三秒，然后返回当前线程是否是终止的boolean值")])]),a._v(" "),t("h4",{attrs:{id:"_5、shutdownnow"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5、shutdownnow"}},[a._v("#")]),a._v(" 5、shutdownNow")]),a._v(" "),t("blockquote",[t("p",[a._v("List Runnable runnableList = threadPool.shutdownNow();")]),a._v(" "),t("p",[a._v("立即中断线程池中正在执行的线程，并返回任务队列中尚未执行的任务")])]),a._v(" "),t("h3",{attrs:{id:"_5、线程池拒绝策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5、线程池拒绝策略"}},[a._v("#")]),a._v(" 5、线程池拒绝策略")]),a._v(" "),t("h4",{attrs:{id:"_1、abortpolicy"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、abortpolicy"}},[a._v("#")]),a._v(" 1、AbortPolicy")]),a._v(" "),t("blockquote",[t("p",[a._v("直接抛出异常")])]),a._v(" "),t("h4",{attrs:{id:"_2、discardpolicy"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、discardpolicy"}},[a._v("#")]),a._v(" 2、DiscardPolicy")]),a._v(" "),t("blockquote",[t("p",[a._v("直接丢弃任务")])]),a._v(" "),t("h4",{attrs:{id:"_3、discardoldestpolicy"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、discardoldestpolicy"}},[a._v("#")]),a._v(" 3、DiscardOldestPolicy")]),a._v(" "),t("blockquote",[t("p",[a._v("丢弃队列中最老的任务")])]),a._v(" "),t("h4",{attrs:{id:"_4、callerrunspolicy"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、callerrunspolicy"}},[a._v("#")]),a._v(" 4、CallerRunsPolicy")]),a._v(" "),t("blockquote",[t("p",[a._v("发送任务的线程去执行多出来的任务")])]),a._v(" "),t("h3",{attrs:{id:"_6、线程池状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6、线程池状态"}},[a._v("#")]),a._v(" 6、线程池状态")]),a._v(" "),t("h4",{attrs:{id:"_1、running状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、running状态"}},[a._v("#")]),a._v(" 1、RUNNING状态")]),a._v(" "),t("blockquote",[t("p",[a._v("接受新任务并处理排队任务")])]),a._v(" "),t("h4",{attrs:{id:"_2、shutdown状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、shutdown状态"}},[a._v("#")]),a._v(" 2、SHUTDOWN状态")]),a._v(" "),t("blockquote",[t("p",[a._v("不接受新任务，但是处理排队任务")])]),a._v(" "),t("h4",{attrs:{id:"_3、stop状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、stop状态"}},[a._v("#")]),a._v(" 3、STOP状态")]),a._v(" "),t("blockquote",[t("p",[a._v("不接受新任务，也不处理排队任务，并中断正在进行的任务")])]),a._v(" "),t("h4",{attrs:{id:"_4、tidying状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、tidying状态"}},[a._v("#")]),a._v(" 4、TIDYING状态")]),a._v(" "),t("blockquote",[t("p",[a._v("所有任务都已经终止，workCount为0时，线程池会转换到TIDYING状态，并运行terminate()钩子方法")])]),a._v(" "),t("h4",{attrs:{id:"_5、terminated状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5、terminated状态"}},[a._v("#")]),a._v(" 5、TERMINATED状态")]),a._v(" "),t("blockquote",[t("p",[a._v("terminate() 方法运行完成，线程池终止")])]),a._v(" "),t("h2",{attrs:{id:"_2、threadlocal"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、threadlocal"}},[a._v("#")]),a._v(" 2、ThreadLocal")]),a._v(" "),t("blockquote",[t("p",[a._v("ThreadLocal两个重要的使用场景")]),a._v(" "),t("ul",[t("li",[a._v("每个线程需要一个独享的对象，（通常是一些工具类等）")]),a._v(" "),t("li",[a._v("每个线程需要保存全局变量，（例如拦截器获取用户信息）可以让每个方法都直接使用，避免传参数等麻烦")])])]),a._v(" "),t("h3",{attrs:{id:"_1、原理分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、原理分析"}},[a._v("#")]),a._v(" 1、原理分析")]),a._v(" "),t("blockquote",[t("p",[a._v("Thread、ThreadLocalMap、ThreadLocal")]),a._v(" "),t("p",[a._v("每个Thread对象中都有一个ThreadLocalMap成员变量")]),a._v(" "),t("p",[a._v("get()方法先取出当前线程的ThreadLocalMap，然后调用map.getEntry()，把本地ThreadLocal的引用作为参数传入，取出Map中属于本ThreadLocal的val")]),a._v(" "),t("p",[a._v("ThreadLocalMap是一个Entry[]的数据结构，Entry类似Map，也属于键值对结构，Entry解决key冲突采用的是线性探测法，如果发生冲突，就继续查找下一个空的位置，而不是类似HashMap进行链表的转换")])]),a._v(" "),t("h2",{attrs:{id:"_3、java中的锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、java中的锁"}},[a._v("#")]),a._v(" 3、Java中的锁")]),a._v(" "),t("blockquote",[t("p",[a._v("锁的分类：")]),a._v(" "),t("p",[a._v("1、线程要不要锁住同步资源：悲观锁和乐观锁")]),a._v(" "),t("p",[a._v("2、多线程能否共享一把锁：共享锁和独占锁")]),a._v(" "),t("p",[a._v("3、多线程竞争时是否排队：公平锁和非公平锁")]),a._v(" "),t("p",[a._v("4、同一个线程能否重复获得同一把锁：可重入锁和非可重入锁")]),a._v(" "),t("p",[a._v("5、是否可以中断：可中断锁和非可中断锁")]),a._v(" "),t("p",[a._v("6、等锁的过程：自旋锁和非自旋锁（阻塞）")])]),a._v(" "),t("h3",{attrs:{id:"_1、悲观锁和乐观锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、悲观锁和乐观锁"}},[a._v("#")]),a._v(" 1、悲观锁和乐观锁")]),a._v(" "),t("blockquote",[t("p",[a._v("悲观锁的劣势：")]),a._v(" "),t("p",[a._v("1、阻塞和唤醒带来的性能劣势")]),a._v(" "),t("p",[a._v("2、可能陷入永久阻塞，如果持有锁的线程被永久阻塞，比如遇到了无限循环、死锁等活跃性问题，那么等待当前线程释放锁等别的线程，将永远无法拿到锁")]),a._v(" "),t("p",[a._v("3、优先级反转：如果持有锁等线程优先级比较低，那就会导致我们设置的优先级高的线程也无法提前运行")])]),a._v(" "),t("ul",[t("li",[t("p",[a._v("悲观锁")]),a._v(" "),t("blockquote",[t("p",[a._v("在获取并修改数据时，每次都会锁住数据，让其他线程无法访问，可以确保数据的万无一失")]),a._v(" "),t("p",[t("code",[a._v("java中悲观锁的实现就是synchronized和Lock相关类")])]),a._v(" "),t("p",[a._v("使用场景：")]),a._v(" "),t("p",[a._v("适合并发写入比较多的情况，适用于临界区持锁时间比较长的情况，悲观锁可以避免大量的无用自旋等消耗，例如代码有IO操作、代码复杂耗时、或者竞争激烈")])])]),a._v(" "),t("li",[t("p",[a._v("乐观锁")]),a._v(" "),t("blockquote",[t("p",[a._v("获得和修改数据时不会锁住数据，在更新的时候会对比自己修改期间数据有没有被别的线程改变过，如果没有改变，则正常修改数据，如果改变过则不进行更新，而是放弃、报错、重试等策略")]),a._v(" "),t("p",[a._v("乐观锁的实现一般是利用CAS算法实现")]),a._v(" "),t("p",[t("code",[a._v("java中乐观锁典型例子就是原子类和并发容器等")])]),a._v(" "),t("p",[a._v("使用场景：")]),a._v(" "),t("p",[a._v("适合并发写入比较少，大部分时读取的场景，不加锁能让读取性能大幅提高")])])])]),a._v(" "),t("h3",{attrs:{id:"_2、可重入锁和非可重入锁-reentrantlock"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、可重入锁和非可重入锁-reentrantlock"}},[a._v("#")]),a._v(" 2、可重入锁和非可重入锁 （ReentrantLock）")])])}),[],!1,null,null,null);t.default=r.exports}}]);