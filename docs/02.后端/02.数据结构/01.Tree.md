---
title: Tree
date: 2022-08-09 09:43:08
permalink: /pages/daf229/
categories:
  - 后端
  - 数据结构
tags:
  - Tree
author: 
  name: Coder
  link: https://github.com/zyb-github
---

# Tree（树）

# Stark（栈）

## 1、栈的定义

> 栈是限定仅在表尾元素进行插入和删除操作的线性表。允许插入、删除的一端称为**栈顶**，另一端称为**栈底**，不包含任何数据元素的栈称为**空栈**
>
> 假设栈 S = (a1,a2,a3,...,an),则a1称为**栈底元素**，an为**栈顶元素**。栈中元素按照a1,a2...an的顺序进栈，退栈从栈顶元素开始出栈。所以，栈的修改是按后进先出的原则进行的。因此，栈又被称为后进先出（LIFO）的线性表。
>
> 入栈和出栈是栈的两个主要操作，每一次进栈的元素总是成为当前的栈顶元素，而每一次出栈的元素总是当前的栈顶元素。所以栈顶的位置随着元素的插入和删除而变化，为此，需要一个称为栈顶指针的位置指示器来表示栈顶的当前位置。

## 2、栈的基本操作

+ 初始化--构造一个空的栈
+ 入栈--在栈顶位置插入一个新元素
+ 出栈--删除栈顶元素
+ 获取--取栈顶数据元素
+ 判空--判断当前栈是否为空
+ 求长度--求出栈中数据元素的个数
+ 正序遍历--依次访问栈中每个元素并输出
+ 销毁--销毁一个已存在的栈

## 3、栈的应用

### 1、数制转换

> 将十进制的数N转换为r进制的数，其方法是利用辗转相除法，已N=3467，r=8为例。转换方法如下：
>
> |  N   | N/8(整除) | N%8(求余) |      |
> | :--: | :-------: | :-------: | :--: |
> | 3467 |    433    |     3     |  低  |
> | 433  |    54     |     1     |      |
> |  54  |     6     |     6     |      |
> |  6   |     0     |     6     |  高  |
>
> 所以 （3467）10 = （6613）8
>
> 算法思想：
>
> 当N>0时，重复步骤1,2
>
> 1、当N≠0，则将N%r压入栈s中，执行步骤2；若N=0，将栈s的内容依次出栈，算法结束
>
> 2、用N/r代替N，执行步骤1
>
> 代码展示
>
> ```java
> public class test {
>     public static void conversion(int N,int r){
>         Stack<Integer> s = new Stack<Integer>();
>         /*定义一个顺序栈*/
>         while(N!=0){
>             //余数进栈
>             s.push(N % r);
>             N = N / r;
>         }
>         System.out.println("转换结果为：");
>         while(!s.empty()){
>             System.out.print(s.pop());
>         }
>     }
> 
>     public static void main(String[] args) {
>         int N = 3467;
>         int r = 8;
>         conversion(N,r);
>     }
> }
> ```

### 2、括号匹配

> 括号匹配问题也是计算机程序设计中常见的问题，为简化问题，假设表达式中只允许有两种括号：圆括号和方括号，嵌套的顺序是任意的, [()(])不是正确的格式
>
> 可能出现的不匹配的情况有：
>
> 1）、到来的右括号不是所期待的，如：输入 " [ ( [ ",这时候最期待的是 " ] ",如果这时候输入的是一个 " ) ",则和左括号不相匹配。
>
> 2）、到来的是“不速之客”，如输入 “ [  ( )  ] ”，这时并不需要右括号，如果这时输入的是一个右括号，则匹配不成功。
>
> 3）、直到结束，也没有到来所期待的括弧，如输入“[ (  ( ) ) ”,如果此时表达式结束，但这时还有一个 “ ] ”没有匹配成功。
>
> 可以看到，检验括号是否匹配的方法可用“期待的急迫程度”这个概念来描述，即最后输入的左括号应最先被匹配，满足后进先出，所以校验括号匹配的方法要用到栈。
>
> **算法思想**：如果括号序列不为空，重复步骤1
>
> 1、从括号序列中取出1个括号，分为两种情况：
>
> ​	1）、凡是左括弧，则进栈
>
> ​	2）、凡是出现有括弧，首先检查栈是否为空，若栈为空，则表名该“右括弧”多余，匹配失败。否则和栈顶元素比较，若相匹配，则“左括弧出栈”，否则表明不匹配。
>
> 2、括号序列结束时，若栈空，则表示表达式匹配正确，否则表示左括弧有余，匹配失败
>
> 代码：
>
> ```java
> public class test {
>     public static boolean matching(char[] exp){
>         int state = 1, i = 0;
>         Stack<Character> s = new Stack<>();
>         while(i < exp.length && state == 1){
>             switch(exp[i]){
>                 case '[':
>                 case '(':
>                     //入栈
>                     s.push(exp[i]);
>                     i++;
>                     break;
>                 case ']':
>                     if(!s.empty()){
>                         Character pop = s.pop();
>                         if('[' == pop){
>                             i++;
>                             break;
>                         }else{
>                             state = 0;
>                             break;
>                         }
>                     }else{
>                         state = 0;
>                         break;
>                     }
>                 case ')':
>                     if(!s.empty()){
>                         //出栈并比较
>                         Character pop = s.pop();
>                         if('(' == pop){
>                             i++;
>                             break;
>                         }else{
>                             state = 0;
>                             break;
>                         }
>                     }else{
>                         state = 0;
>                         break;
>                     }
>                 default:
>                     i++;
>                     break;
>             }
>         }
>         if(s.isEmpty() && state == 1){
>             return true;
>         }
>         return false;
>     }
> 
>     public static void main(String[] args) {
>         if(matching("[([()])]]".toCharArray())){
>             System.out.println("匹配成功！！！");
>         }else{
>             System.out.println("匹配失败！！！");
>         }
>     }
> }
> ```

### 3、表达式求值

> 表达式求值是高级语言编译中的一个基本问题，是栈的典型应用示例，任意一个表达式都是由操作数（OPND）、运算符（OPTR）和界限符（delimiter）组成的。操作数既可以是常数，也可以是被说明为变量或者常量的标识符。运算符可以分为算术运算符、关系运算符和逻辑运算符三类。基本界限符有左右括号和表达式结束符等。
>
> 为简化问题，我们仅讨论四则运算表达式，并且假设一个算数表达式中只包含加、减、乘、除、左右圆括号等符号，并假设#是界限符。在计算机中，算术表达式中包含了算术运算符和算术量（常量、变量、函数），而运算符之间又存在着优先级，编译程序在求值时，不能简单的进行从左到右运算，必须先运算级别高的，再运算级别低的，同一级别运算从左到右。算术四则运算的规则如下：
>
> 1、先乘除、后加减
>
> 2、先括号内，再括号外
>
> 3、同级别先左后右
>
> 例如： 3 + 4 * ( 5 + 6 ),需要先计算括号中的5+6，然后得到的结果再预与4相乘，最后再加3得到结果
>
> **我们把运算符和界限符统称为算符**，根据上述三条运算规则，在任意相继出现的算符&1和&2之间至多是下面三种关系之一：
>
> + &1 < &2 &1的优先权低于&2
> + &1 = &2 &1的优先权等于&2
> + &1 > &2 &1的优先权高于&2
>
> 下表定义了算符之间的这种优先关系，为了算法简洁，在表达式的最左边和最右边虚设了一个#构成整个表达式的一对括号。
>
> | &1 &2 |  +   |  -   |  *   |  /   |  (   |  )   |  #   |
> | :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
> |   +   |  >   |  >   |  <   |  <   |  <   |  >   |  >   |
> |   -   |  >   |  >   |  <   |  <   |  <   |  >   |  >   |
> |   *   |  >   |  >   |  >   |  >   |  <   |  >   |  >   |
> |   /   |  >   |  >   |  >   |  >   |  <   |  >   |  >   |
> |   (   |  >   |  >   |  >   |  >   |  >   |  =   |      |
> |   )   |  <   |  <   |  <   |  <   |  <   |  >   |  >   |
> |   #   |  <   |  <   |  <   |  <   |  <   |      |  =   |
>
> 由表可知：
>
> 1、# 的优先级最低，当# = #表示整个表达式结束。
>
> 2、同级别的算符遇到时，左边算符的优先级高于右边算符的优先级，如 + 与 + ，+ 与 - 等
>
> 3、”（ “ 左括号在左边出现时其优先级低于右边出现的算符，如 + - * 等， “（” = “）” 表示括号内运算结束；“（”在右边出现时，其优先级高于左边出现的算符，如 + - *等
>
> 4、“）”在左边出现时，其优先级高于右边出现的算符，如+ - *等
>
> 5、“）”与 “（”、“#”与“）”、“（”与“#”之间没有优先关系，在表达式中不允许相继出现，如果出现则认为是语法错误
>
> 实现运算符算法需要使用两个工作栈：一个设为OPTR，用以存储运算符；另一个设为OPND，用于存放操作数或运算的中间结果。
>
> **算法的基本过程如下**：
>
> + 首先初始化操作树栈OPND和运算符栈OPTR，并将表达式起始符号#压入运算符栈
> + 依次读入表达式中的每个字符，若是操作数，则直接进入操作数栈OPND，若是运算符，则与运算符栈OPTR的栈顶运算符进行优先权比较，并做如下处理：
>   + 若栈顶运算符的优先级低于刚读入的运算符，则让刚读入的运算符进OPTR栈
>   + 若栈顶运算符的优先级高于刚读入的运算符，则将栈顶运算符退栈，送入&，同时将操作数栈OPND退栈两次，得到两个操作数 a、b，对ab进行&运算符后，将运算结果作为中间结果推入OPND栈。注意先出栈的元素a为第二操作数，后出栈的元素b为第一操作数
>   + 若栈顶元素优先级与刚读入的运算符的优先级相同，说明左右括号相遇，只需将栈顶运算符（左括号）退栈即可。
> + 当OPTR栈的栈顶元素和当前读入的字符均为#时，说明表达式起始符#和表达式终止符#相遇，整个表达式求值完毕
>
> 例如：用栈求 3 * 4 + ( 8 - 10 /  5 ) * 2 的值，栈的变化如下表所示
>
> | 步骤 |                             说明                             | 操作数栈OPND | 运算符栈OPTR |
> | :--: | :----------------------------------------------------------: | :----------: | :----------: |
> |  1   |              开始时，两栈为空，压入#到运算符栈               |              |      #       |
> |  2   |                 读入3，是操作数，进入OPND栈                  |      3       |      #       |
> |  3   |                读入*，优先级高于#，进入OPTR栈                |      3       |     #  *     |
> |  4   |                 读入4，是操作数，进入OPND栈                  |     3 4      |     # *      |
> |  5   | 读入+，优先级小与*，\*出栈进行计算，3\*4=12，结果压入OPND栈  |      12      |      #       |
> |  6   |                读入+，优先级大与#，进入OPTR栈                |      12      |     # +      |
> |  7   |                读入(,优先级大于+，进入OPTR栈                 |      12      |    # + (     |
> |  8   |                 读入8，是操作数，进入OPND栈                  |     12 8     |    # + (     |
> |  9   |                读入-,优先级大于（，进入OPTR栈                |     12 8     |   # + ( -    |
> |  10  |                 读入10，是操作数，进入OPND栈                 |   12 8 10    |   # + ( -    |
> |  11  |                读入/,优先级大于-，进入OPTR栈                 |   12 8 10    |  # + ( - /   |
> |  12  |                 读入5，是操作数，进入OPND栈                  |  12 8 10 5   |  # + ( - /   |
> |  13  |  读入 ），优先级小与 /,/出栈进行运算，10 / 5 =2,2压入OPND栈  |    12 8 2    |   # + ( -    |
> |  14  |  读入 ），优先级小与 -，-出栈进行运算，8 -2 = 6,6压入OPND栈  |     12 6     |    # + (     |
> |  15  | 读入 ），左右括号相遇，优先级相等，括号出栈，进行下一步运算  |     12 6     |     # +      |
> |  16  |                读入*,优先级大于+，进入OPTR栈                 |     12 6     |    # + *     |
> |  17  |                 读入2，是操作数，进入OPND栈                  |    12 6 2    |    # + *     |
> |  18  |     读入#，优先级低于\*，\*出栈运算,2*6=12,12压入OPND栈      |    12 12     |     # +      |
> |  19  |     读入#，优先级低于+，+出栈运算,12+12=24,24压入OPND栈      |      24      |      #       |
> |  20  | 读入#，OPTR栈也是#，表达式求值结束，OPND栈中的栈顶元素为计算结果 |      24      |      #       |
>
> 代码：
>
> ```java
> public class test {
> 
>     public static boolean isOperator(char c){
>         switch (c){
>             case '#':
>             case '+':
>             case '-':
>             case '*':
>             case '/':
>             case '(':
>             case ')':
>                 return true;
>             default:
>                 return false;
>         }
>     }
>     static char OP[][]={
>             {'>','>','<','<','<','>','>'},
>             {'>','>','<','<','<','>','>'},
>             {'>','>','>','>','<','>','>'},
>             {'>','>','>','>','<','>','>'},
>             {'<','<','<','<','<','=','E'},
>             {'>','>','>','>','E','>','>'},
>             {'<','<','<','<','<','E','='},
>     };
> 
>     public static int getOperatorID(char operator){
>         int retCode = -1;
>         switch (operator){
>             case '+':
>                 retCode = 0;
>                 break;
>             case '-':
>                 retCode = 1;
>                 break;
>             case '*':
>                 retCode = 2;
>                 break;
>             case '/':
>                 retCode = 3;
>                 break;
>             case '(':
>                 retCode = 4;
>                 break;
>             case ')':
>                 retCode = 5;
>                 break;
>             case '#':
>                 retCode = 6;
>                 break;
>         }
>         return retCode;
>     }
> 
>     public static char precede(char operator1,char operator2){
>         int operatorID1,operatorID2;
>         operatorID1 = getOperatorID(operator1);
>         operatorID2 = getOperatorID(operator2);
>         if(operatorID1 < 0 || operatorID1 > 6 || operatorID2 < 0 || operatorID2 > 6){
>             return 'E';
>         }
>         return (OP[operatorID1][operatorID2]);
>     }
> 
>     /**
>      * @Description op1第一操作数，op2第二操作数
>      **/
>     public static double operate(double op1,char cal,double op2){
>         switch (cal){
>             case '+':
>                 return op1 + op2;
>             case '-':
>                 return op1 - op2;
>             case '*':
>                 return op1 * op2;
>             case '/':
>                 return op1 / op2;
>             default:
>                 return 0;
>         }
>     }
> 
>     public static double expEvaluation(char[] exp){
>         //读入一个简单算术表达式并计算值
>         char thera;
>         int i = 0;
>         double b, a, val;
>         //运算符栈
>         Stack<Character> OPTR = new Stack<>();
>         //操作数栈
>         Stack<Double> OPND = new Stack<>();
>         OPTR.push('#');
> 
>         while (exp[i] != '#' || OPTR.lastElement() != '#'){
>             if(!isOperator(exp[i])){
>                 //存放数字的临时变量
>                 double temp;
>                 //将字符转换为十进制数
>                 temp = exp[i] - '0';
>                 i++;
>                 while(!isOperator(exp[i]) && i < exp.length){
>                     //因为传入的超过10的数字会被char类型分隔，例如传入100，在char[]中是[ 1,0,0],所以进行循环组装
>                     //将逐个读入的操作数各个位置转化为十进制数
>                     temp = temp * 10 + exp[i] - '0';
>                     i++;
>                 }
>                 //不是运算符，入栈OPND
>                 OPND.push(temp);
>             }else{
>                 //判断栈顶元素和表达式当前元素的优先级
>                 switch (precede(OPTR.lastElement(),exp[i])){
>                     case '<':
>                         //栈顶元素优先级低，入栈
>                         OPTR.push(exp[i]);
>                         i++;
>                         break;
>                     case '=':
>                         //优先级相等，脱括号并接收下一字符串
>                         OPTR.pop();
>                         i++;
>                         break;
>                     case '>':
>                         //栈顶元素优先级高，退栈进行运算，并将结果入栈
>                         thera = OPTR.pop();
>                         b = OPND.pop();
>                         a = OPND.pop();
>                         OPND.push(operate(a,thera,b));
>                         break;
>                 }
>             }
>         }
>         val = OPND.lastElement();
>         return val;
>     }
> 
>     public static void main(String[] args) {
>         String exp = "3*4+(8-10/5)*2";
>         char[] us = (exp+"#").toCharArray();
>         System.out.println("表达式"+exp+"的输出结果为：");
>         System.out.println(expEvaluation(us));
>     }
> }
> ```



